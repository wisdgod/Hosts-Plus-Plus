package proxy

import (
	"bufio"
	"crypto/tls"
	"fmt"
	"io"
	"log"
	"net"
	"net/http"
	"regexp"
	"strings"
	"time"
)

// Server 代表代理服务器
type Server struct {
	config *Config
}

// NewServer 创建一个新的 Server 实例
func NewServer(config *Config) *Server {
	return &Server{config: config}
}

// Start 开始监听指定的端口并处理传入的连接
func (s *Server) Start() error {
	listener, err := net.Listen("tcp", fmt.Sprintf(":%d", s.config.Port))
	if err != nil {
		return fmt.Errorf("无法启动代理服务器: %v", err)
	}
	defer listener.Close()

	log.Printf("代理服务器正在监听端口 %d...\n", s.config.Port)

	for {
		conn, err := listener.Accept()
		if err != nil {
			log.Printf("接受连接失败: %v", err)
			continue
		}

		go s.handleConnection(conn)
	}
}

// handleConnection 处理传入的连接并根据连接类型进行路由
func (s *Server) handleConnection(conn net.Conn) {
	defer conn.Close()

	// 设置读取超时以防止连接挂起
	conn.SetReadDeadline(time.Now().Add(10 * time.Second))

	// 读取前几个字节来确定连接类型 (HTTP, HTTPS, or SOCKS)
	buffer := make([]byte, 1)
	if _, err := conn.Read(buffer); err != nil {
		log.Printf("读取连接失败: %v", err)
		return
	}

	// 根据第一个字节确定连接类型
	switch buffer[0] {
	case 0x05:
		// SOCKS5 连接
		s.handleSOCKS5(conn)
	case 0x04:
		// SOCKS4 连接
		s.handleSOCKS4(conn)
	default:
		// 假定为 HTTP/HTTPS 连接
		s.handleHTTP(conn, buffer)
	}
}

// handleHTTP 处理 HTTP 和 HTTPS 连接
func (s *Server) handleHTTP(conn net.Conn, firstByte []byte) {
	// 预读第一个字节以检查是否是 HTTPS
	buf := append(firstByte, make([]byte, 1023)...)
	n, err := conn.Read(buf[1:])
	if err != nil && err != io.EOF {
		log.Printf("读取 HTTP/HTTPS 请求失败: %v", err)
		return
	}
	buf = buf[:n+1]

	reader := bufio.NewReader(io.MultiReader(strings.NewReader(string(buf)), conn))

	if isHTTPS(buf) {
		s.handleHTTPS(conn, reader)
	} else {
		s.serveHTTP(conn, reader)
	}
}

// isHTTPS 检查连接是否为 HTTPS
func isHTTPS(buf []byte) bool {
	return len(buf) > 0 && buf[0] == 0x16
}

// handleHTTPS 处理 HTTPS 连接
func (s *Server) handleHTTPS(conn net.Conn, reader *bufio.Reader) {
	log.Println("处理 HTTPS 连接...")

	// 创建 TLS 监听器
	tlsConfig := &tls.Config{
		InsecureSkipVerify: true,
	}
	tlsConn := tls.Server(conn, tlsConfig)
	defer tlsConn.Close()

	// 继续处理 HTTPS 请求
	s.serveHTTP(tlsConn, reader)
}

// serveHTTP 处理 HTTP 请求，应用规则并进行转发
func (s *Server) serveHTTP(conn net.Conn, reader *bufio.Reader) {
	log.Println("处理 HTTP 连接...")

	// 使用 bufio.Reader 读取请求
	request, err := http.ReadRequest(reader)
	if err != nil {
		log.Printf("解析 HTTP 请求失败: %v", err)
		return
	}

	// 应用代理规则
	s.applyRules(request)

	// 转发请求
	client := &http.Client{}
	response, err := client.Do(request)
	if err != nil {
		// 手动构造 HTTP 错误响应并写入连接
		httpError(conn, http.StatusBadGateway, fmt.Sprintf("请求转发失败: %v", err))
		return
	}
	defer response.Body.Close()

	// 将响应返回给客户端
	if err := response.Write(conn); err != nil {
		log.Printf("响应发送失败: %v", err)
	}
}

// applyRules 应用代理规则，修改请求或决定如何处理
func (s *Server) applyRules(r *http.Request) {
	for _, rule := range s.config.Rules {
		if rule.Regex {
			// 处理正则表达式匹配
			// 此处为简化，仅展示逻辑流程
			if match, _ := regexp.MatchString(rule.From[0], r.URL.String()); match {
				r.URL.Host = rule.To
				break
			}
		} else {
			for _, from := range rule.From {
				if r.URL.Host == from {
					r.URL.Host = rule.To
					break
				}
			}
		}
	}
}

// httpError 手动生成 HTTP 错误响应
func httpError(conn net.Conn, statusCode int, errorMsg string) {
	response := fmt.Sprintf("HTTP/1.1 %d %s\r\nContent-Type: text/plain\r\nContent-Length: %d\r\n\r\n%s",
		statusCode, http.StatusText(statusCode), len(errorMsg), errorMsg)
	conn.Write([]byte(response))
}

// handleSOCKS5 处理 SOCKS5 连接
func (s *Server) handleSOCKS5(conn net.Conn) {
	log.Println("处理 SOCKS5 连接...")
	// 实现 SOCKS5 协议处理
	// 这是一个简单的占位符
}

// handleSOCKS4 处理 SOCKS4 连接
func (s *Server) handleSOCKS4(conn net.Conn) {
	log.Println("处理 SOCKS4 连接...")
	// 实现 SOCKS4 协议处理
	// 这是一个简单的占位符
}

// singleUseListener 包装一个 net.Conn 并满足 net.Listener 接口
type singleUseListener struct {
	conn net.Conn
}

func (l *singleUseListener) Accept() (net.Conn, error) {
	if l.conn == nil {
		return nil, fmt.Errorf("连接已经被接受")
	}
	conn := l.conn
	l.conn = nil
	return conn, nil
}

func (l *singleUseListener) Close() error {
	if l.conn != nil {
		return l.conn.Close()
	}
	return nil
}

func (l *singleUseListener) Addr() net.Addr {
	return l.conn.LocalAddr()
}

package proxy

import (
	"fmt"
	"io"
	"log"
	"os"

	"gopkg.in/yaml.v3"
)

// Config 是一个结构体，用于表示配置文件中的内容
type Config struct {
	Port      int         `yaml:"port"`       // 服务器监听的端口号
	AllowLAN  bool        `yaml:"allow-lan"`  // 是否允许局域网访问
	LogLevel  string      `yaml:"log-level"`  // 日志记录的详细程度
	LogOutput string      `yaml:"log-output"` // 日志输出的方式
	LogFile   string      `yaml:"log-file"`   // 日志文件路径（如果 log-output 设置为 file）
	DNS       DNSConfig   `yaml:"dns"`        // DNS 配置
	Proxy     ProxyConfig `yaml:"proxy"`      // 代理服务器的配置
	Bypass    []string    `yaml:"bypass"`     // 不走代理的 IP 或域名
	Cache     CacheConfig `yaml:"cache"`      // 缓存配置
	Rules     []Rule      `yaml:"rules"`      // 代理规则配置
	SSL       SSLConfig   `yaml:"ssl"`        // SSL/TLS 配置
}

// DNSConfig 结构体表示 DNS 配置
type DNSConfig struct {
	Enable     bool     `yaml:"enable"`     // 是否启用 DNS 配置
	Nameserver []string `yaml:"nameserver"` // 使用的 DNS 服务器列表
}

// ProxyConfig 结构体表示代理服务器的配置
type ProxyConfig struct {
	UseSystemProxy bool   `yaml:"use-system-proxy"` // 是否使用系统代理配置
	Enable         bool   `yaml:"enable"`           // 是否启用自定义代理设置
	Server         string `yaml:"server"`           // 自定义代理服务器的地址
	Username       string `yaml:"username"`         // 代理服务器的用户名（可选）
	Password       string `yaml:"password"`         // 代理服务器的密码（可选）
	Type           string `yaml:"type"`             // 代理服务器的类型 (http, socks4, socks5)
}

// CacheConfig 结构体表示缓存配置
type CacheConfig struct {
	DNS        bool `yaml:"dns"`         // 是否缓存 DNS 查询结果
	ProxyRules bool `yaml:"proxy-rules"` // 是否缓存代理规则
}

// SSLConfig 结构体表示 SSL/TLS 配置
type SSLConfig struct {
	CACertPath   string `yaml:"ca-cert-path"`  // CA 证书路径
	CAKeyPath    string `yaml:"ca-key-path"`   // CA 私钥路径
	VerifyClient bool   `yaml:"verify-client"` // 是否验证客户端证书
}

// Rule 结构体表示代理规则
type Rule struct {
	Type  string   `yaml:"type"`  // 规则类型 (single-to-single, multi-to-single, multi-to-multi)
	From  []string `yaml:"from"`  // 原始目标
	To    string   `yaml:"to"`    // 重定向后的目标
	Regex bool     `yaml:"regex"` // 是否启用正则表达式匹配
}

// LoadConfig 函数从指定的 YAML 配置文件路径加载配置，并将其解析到 Config 结构体中
func LoadConfig(configPath string) (*Config, error) {
	// 打开配置文件
	file, err := os.Open(configPath)
	if err != nil {
		return nil, fmt.Errorf("无法打开配置文件: %v", err)
	}
	defer file.Close()

	// 读取文件内容
	data, err := io.ReadAll(file)
	if err != nil {
		return nil, fmt.Errorf("无法读取配置文件: %v", err)
	}

	var config Config

	// 解析 YAML 数据到 Config 结构体
	err = yaml.Unmarshal(data, &config)
	if err != nil {
		return nil, fmt.Errorf("配置文件解析错误: %v", err)
	}

	// 设置默认值
	setDefaultValues(&config)

	// 配置日志输出
	if err := setupLogging(config); err != nil {
		return nil, err
	}

	log.Printf("配置文件从 %s 加载成功\n", configPath)
	return &config, nil
}

// setDefaultValues 为缺少的配置字段设置默认值
func setDefaultValues(config *Config) {
	if config.Port == 0 {
		config.Port = 7769
	}
	if config.LogLevel == "" {
		config.LogLevel = "info"
	}
	if config.LogOutput == "" {
		config.LogOutput = "console"
	}
}

// setupLogging 配置日志输出
func setupLogging(config Config) error {
	if config.LogOutput == "file" && config.LogFile != "" {
		logFile, err := os.OpenFile(config.LogFile, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
		if err != nil {
			return fmt.Errorf("无法打开日志文件: %v", err)
		}
		log.SetOutput(logFile)
	} else {
		log.SetOutput(os.Stdout)
	}

	// 设置日志级别
	switch config.LogLevel {
	case "debug":
		log.SetFlags(log.LstdFlags | log.Lshortfile)
	case "info":
		log.SetFlags(log.LstdFlags)
	case "warning", "error":
		log.SetFlags(log.LstdFlags)
	default:
		log.Printf("未知的日志级别: %s，使用 info 级别\n", config.LogLevel)
		log.SetFlags(log.LstdFlags)
	}

	return nil
}

// UpdateRules 动态更新代理规则
func (c *Config) UpdateRules(newRules []Rule) {
	c.Rules = newRules
	log.Println("代理规则已更新")
	// 可选择将规则持久化到配置文件
}

// SaveConfig 将配置持久化到指定路径的 YAML 文件中
func (c *Config) SaveConfig(configPath string) error {
	data, err := yaml.Marshal(c)
	if err != nil {
		return fmt.Errorf("配置保存失败: %v", err)
	}

	err = os.WriteFile(configPath, data, 0644)
	if err != nil {
		return fmt.Errorf("无法写入配置文件: %v", err)
	}

	log.Printf("配置文件已保存到 %s\n", configPath)
	return nil
}
